---
layout: ctf
title: "SpookiePass"
date: 2025-10-05
category: "reverse"
description: "reverse de binario"
image: "/assets/images/spookiepass.png"
---

## Información del Challenge

| Campo | Valor |
|-------|-------|
| **Nombre** | SpookiePass |
| **Plataforma** | HackTheBox |
| **Categoría** | Reverse Engineering |
| **Dificultad** | Very Easy |
| **SO** | Linux x64 |

## Objetivo

Obtener acceso al sistema encontrando la contraseña secreta que está hardcodeada en el binario mediante técnicas de ingeniería inversa.

## Reconocimiento Inicial

### Análisis del Binario

Comenzamos descargando el archivo del challenge y verificando su tipo:

```bash
┌──(kali㉿kali)-[~/htb/challenges/spookiepass]
└─$ file spookiepass
spookiepass: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, not stripped
```

Observaciones importantes:
- **ELF 64-bit**: Binario de Linux para arquitectura x64
- **Dynamically linked**: Usa librerías compartidas
- **Not stripped**: Los símbolos de debug NO han sido eliminados (buena noticia para el análisis)

### Ejecución del Programa

Ejecutamos el binario para ver su comportamiento:

```bash
┌──(kali㉿kali)-[~/htb/challenges/spookiepass]
└─$ chmod +x spookiepass

┌──(kali㉿kali)-[~/htb/challenges/spookiepass]
└─$ ./spookiepass
[ ** WELCOME TO THE SPOOKIEST PLACE **]
Before we let you in, you'll need to give us the secret password
> test123
You're not a real ghost; clear off!
```

El programa solicita una contraseña y, al introducir una incorrecta, nos rechaza el acceso.

## Análisis Estático

### Strings - Primera Aproximación

La forma más rápida de resolver challenges sencillos de RE es buscar strings interesantes:

```bash
┌──(kali㉿kali)-[~/htb/challenges/spookiepass]
└─$ strings spookiepass | grep -i "secret\|password\|pass"
Before we let you in, you'll need to give us the secret password
s3cr3t_p455_f0r_gh0st5_4nd_gh0ul5
```

Encontramos lo que parece ser la contraseña: `s3cr3t_p455_f0r_gh0st5_4nd_gh0ul5`

### Verificación

```bash
┌──(kali㉿kali)-[~/htb/challenges/spookiepass]
└─$ ./spookiepass
[ ** WELCOME TO THE SPOOKIEST PLACE **]
Before we let you in, you'll need to give us the secret password
> s3cr3t_p455_f0r_gh0st5_4nd_gh0ul5
Welcome inside!
HTB{sp00ky_str1ng_c0mp4r1s0n_1s_n0t_s3cur3}
```

Flag obtenida, pero vamos a profundizar en el análisis para entender exactamente cómo funciona el binario.

## Análisis Profundo con IDA

### Importación del Binario

1. Abrimos IDA Pro
2. Cargamos el archivo `spookiepass`
3. Dejamos que IDA realice el análisis automático
4. Navegamos a la función `main`

### Función Main

Al examinar la función `main` con el decompilador de IDA (F5), obtenemos:

```c
int main(void) {
    char input[128];
    char *newline_ptr;
    int cmp_result;
    
    puts("[ ** WELCOME TO THE SPOOKIEST PLACE **]");
    printf("Before we let you in, you'll need to give us the secret password\n> ");
    
    // Leer input del usuario
    fgets(input, 0x80, stdin);
    
    // Buscar y eliminar el '\n' del final
    newline_ptr = strchr(input, '\n');
    if (newline_ptr != NULL) {
        *newline_ptr = '\0';
    }
    
    // Comparar con la contraseña hardcodeada
    cmp_result = strcmp(input, "s3cr3t_p455_f0r_gh0st5_4nd_gh0ul5");
    
    if (cmp_result == 0) {
        puts("Welcome inside!");
        // Aquí se imprime la flag
    } else {
        puts("You're not a real ghost; clear off!");
    }
    
    return 0;
}
```

### Análisis del Assembly (Vista de Grafos)

En la vista de grafos de IDA, podemos ver el flujo del programa:

#### Bloque 1: Preparación y Mensajes Iniciales

```asm
push    rbp
mov     rbp, rsp
sub     rsp, 0C0h
mov     rax, fs:28h
mov     [rbp+var_8], rax
xor     eax, eax
; Imprimir mensaje de bienvenida
call    _puts
; Imprimir solicitud de contraseña
lea     rax, format     ; "Before we let you in, you'll need to gi..."
mov     rdi, rax
mov     eax, 0
call    _printf
```

**Qué hace:**
- Configura el stack frame
- Protección contra buffer overflow (stack canary en `fs:28h`)
- Imprime los mensajes de bienvenida

#### Bloque 2: Lectura de Input

```asm
mov     rdx, cs:stdin@@GLIBC_2_2_5  ; stream
lea     rax, [rbp+s]                ; buffer destino
mov     esi, 80h                    ; n = 128 bytes
mov     rdi, rax                    ; s
call    _fgets
```

**Convención de llamadas x64:**
- `rdi` = 1er argumento: puntero al buffer
- `rsi` = 2do argumento: tamaño máximo (128 bytes)
- `rdx` = 3er argumento: stream (stdin)

**Equivalente en C:**

```c
fgets(input, 128, stdin);
```

#### Bloque 3: Limpieza del Newline

```asm
lea     rax, [rbp+s]
mov     esi, 0Ah        ; '\n' = 0x0A
mov     rdi, rax
call    _strchr
mov     [rbp+var_B8], rax
cmp     [rbp+var_B8], 0
jz      short loc_123C
; Si encontró '\n', lo reemplaza por '\0'
mov     rax, [rbp+var_B8]
mov     byte ptr [rax], 0
```

**Por qué es necesario:**

Cuando el usuario escribe "password" y presiona Enter, `fgets` almacena:
```
"password\n\0"
```

Este código elimina el `\n` para que quede:
```
"password\0"
```

#### Bloque 4: La Comparación Crítica

```asm
loc_123C:
lea     rax, [rbp+s]                    ; Cargar dirección del input
lea     rdx, s2                         ; s2 = "s3cr3t_p455_f0r_gh0st5_4nd_gh0ul5"
mov     rsi, rdx                        ; 2do argumento para strcmp
mov     rdi, rax                        ; 1er argumento para strcmp
call    _strcmp
test    eax, eax                        ; Verificar resultado
jnz     short loc_12C2                  ; Si NO es 0 -> contraseña incorrecta
```

**Análisis detallado:**
- `lea rax, [rbp+s]`: Carga la dirección de memoria del input del usuario
- `lea rdx, s2`: Carga la dirección de la string hardcodeada
- `mov rsi, rdx`: Prepara 2do argumento (contraseña correcta)
- `mov rdi, rax`: Prepara 1er argumento (input del usuario)
- `call _strcmp`: Compara ambas strings carácter por carácter

**Qué devuelve strcmp:**
- `0` si las strings son idénticas
- `< 0` si s1 es "menor" lexicográficamente
- `> 0` si s1 es "mayor" lexicográficamente

**Instrucciones de verificación:**
- `test eax, eax`: Operación AND bit a bit con él mismo (verifica si es 0)
- `jnz loc_12C2`: Jump if Not Zero, salta si las contraseñas NO coinciden

#### Bloque 5: Camino del Éxito

```asm
; Si strcmp devolvió 0 (contraseñas iguales)
lea     rax, aWelcomeInside  ; "Welcome inside!"
mov     rdi, rax
call    _puts
mov     [rbp+var_BC], 0
jmp     short loc_12A6
; Aquí se imprime la flag
```

#### Bloque 6: Camino del Fracaso

```asm
loc_12C2:
lea     rax, aYouReNotAReal  ; "You're not a real ghost; clear off!"
mov     rdi, rax
call    _puts
```

## Conceptos Clave 

### 1. Diferencia entre lea y mov

**lea (Load Effective Address)**: Carga la dirección de memoria

```asm
lea rax, [rbp+s]  ; rax = dirección donde está el string
```

**mov**: Copia el valor

```asm
mov rsi, rdx      ; rsi = contenido de rdx
```

### 2. Convención de Llamadas x64 (System V AMD64 ABI)

Los primeros 6 argumentos se pasan en registros:

| Argumento | Registro |
|-----------|----------|
| 1 | rdi |
| 2 | rsi |
| 3 | rdx |
| 4 | rcx |
| 5 | r8 |
| 6 | r9 |

Para `strcmp(s1, s2)`:
- `rdi` = puntero a s1
- `rsi` = puntero a s2

### 3. Cómo Funciona strcmp

```c
int strcmp(const char *s1, const char *s2) {
    while (*s1 && (*s1 == *s2)) {
        s1++;
        s2++;
    }
    return *(unsigned char *)s1 - *(unsigned char *)s2;
}
```

Compara carácter por carácter hasta encontrar una diferencia o llegar al final.

### 4. Flags y Saltos Condicionales

Después de `test eax, eax`:
- Si `eax = 0` entonces Zero Flag (ZF) = 1
- Si `eax ≠ 0` entonces Zero Flag (ZF) = 0

`jnz` (Jump if Not Zero):
- Salta si ZF = 0 (es decir, si `eax ≠ 0`)

### 5. Funcionamiento de strcmp a Nivel de Memoria

```
strcmp recibe DOS PUNTEROS (direcciones de memoria)
        ↓
Accede al CONTENIDO de esas direcciones
        ↓
Compara los caracteres uno por uno
        ↓
Devuelve el resultado en eax
```

**Ejemplo visual:**

```
rdi = 0x7fff1000  (DIRECCIÓN)
      │
      └──────> Memoria en 0x7fff1000: "mi_password\0"

rsi = 0x00402000  (DIRECCIÓN)
      │
      └──────> Memoria en 0x00402000: "s3cr3t_p455_f0r_gh0st5_4nd_gh0ul5\0"

strcmp compara:
  'm' vs 's' -> DIFERENTES -> devuelve valor != 0
```

## Métodos de Solución

### Método 1: Strings (Más Rápido)

```bash
strings spookiepass | grep -i secret
# Output: s3cr3t_p455_f0r_gh0st5_4nd_gh0ul5
```

### Método 2: IDA Pro (Análisis Completo)

1. Abrir el binario en IDA Pro
2. Esperar el análisis automático
3. Navegar a la función `main` (presionar Shift+F12 para ver strings)
4. Presionar F5 en `main` para ver el pseudocódigo
5. Buscar la referencia a `strcmp`
6. Ver el segundo argumento: `"s3cr3t_p455_f0r_gh0st5_4nd_gh0ul5"`

### Método 3: GDB (Dynamic Analysis)

```bash
gdb ./spookiepass
(gdb) break strcmp
(gdb) run
> test
Breakpoint 1, strcmp()
(gdb) x/s $rdi
0x7fffffffe000: "test"
(gdb) x/s $rsi
0x555555556008: "s3cr3t_p455_f0r_gh0st5_4nd_gh0ul5"
```

### Método 4: Radare2

```bash
r2 -A spookiepass
[0x00001060]> afl | grep main
0x00001189    1     146 sym.main
[0x00001060]> pdf @ sym.main
# Buscar la referencia a la string de comparación
```

## Lecciones de Seguridad

### Vulnerabilidades Identificadas

1. **Hardcoded Credentials**: La contraseña está visible en texto plano dentro del binario
2. **No Stripped Binary**: Los símbolos facilitan el análisis
3. **String Comparison Simple**: `strcmp` es vulnerable a timing attacks
4. **Información Expuesta**: El mensaje de error no debería ser diferente para credenciales incorrectas

